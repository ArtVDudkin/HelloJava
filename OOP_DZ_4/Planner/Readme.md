# `Проект Planner`

## `Цели и задачи проекта:`
С учетом информации полученной ранее знакомимся с параметрическим полиморфизмом и продолжаем погружаться в ООП.
Спроектировать и реализовать планировщик дел для работы с задачами разных приоритетов.
Например:
- определить уровень приоритетов: низкий, средний, немедленное выполнение
- выделить компоненту для хранения данных
- выделить компоненту для организации импорта\экспорта данных
Файл должен содержать следующие данные: id, дату добавления записи, время добавления записи, дедлай задачи, ФИО автора.
Данные хранятся в файле csv/json/xml
Другие компоненты

Студенты должны делать список задач, которые требуется выполнить в рамках реализации проекта, описывать возможные проблемы в своём коде, т.е. как приложение должно реагировать на отсутствие файла при считывании и должна ли она его перезаписывать при сохранении.
Как программа ведёт себя при первом запуске: просто выводит данные на экран или предлагает пользователю выбрать действие.
Вылетает ли программа если файл с данными имеет неверный формат и т.д.

## `Описание проекта:`
Для решения данной задачи код был разделен на две части: клиент, ядро и интерфейс пользователя. Клиент отвечает за запуск программы (содержит точку входа). Ядро включает в себя модель записи, структуру планнера, компоненты, отвечающие за взаимодействие с моделью, обработчиком и отображением (Model, View, Presenter), а также хранение других компонент, необходимых для работы приложения. Пользовательский интерфейс (UI) отвечает за отображение и ввод информации, а также содежит меню для взаимодействия пользователя с приложением. Данные хранятся в файле `data.csv`, путь к которому хранится в файле `Config.java`

# `Описание работы компонент`
## Блок Client:
## Компонента Program.java содержит в себе:
1. Точку входа *main(String[] args)*.
2. Вызов метода `buttonClick()`, запускающего меню пользователя.

## Блок UI:
## Компонента App.java содержит в себе:
1. Метод `buttonClick()` запускающий основные компоненты программы `View` и `Presenter`, а также меню пользователя для работы с приложением.

## Компонента ConsoleView.java имплементирует интерфейс View и содержит в себе:
1. Конструктор `ConsoleView()` для создания экземпляра класса ConsoleView и очистки экрана в момент вызова конструктора.
2. Метод `void print(Notebook currentBook)` выводит в консоль информацию обо всех текущих записях в планнере.
3. Метод `void refresh()` очистка экрана.
4. Метод `void showMenu(int menu)` служит для отображения меню пользователя в консоли (по умолчанию меню самого верхнего уровня).
5. Метод `void setCurrIndex(int value)` служит для установки "курсора" планнера на заданную запись.
6. Метод `String inputText(String text)` служит для отображения приглашения пользователю ввести информацию и ввода информации.

## Блок Core:
## Компонента Note.java имплементирует интерфейс Comparable<Note> и содержит в себе модель записи в планнере, которая содержит:
1. Приватные поля *id*, *date*, *time*, *deadline*, *task*, *author*, *priority* для хранения идентификатора задачи, даты и времени её постановки, дедлайна, содержания задачи, её автора и приоритета.
2. Конструктор `Note(Integer id, String date, String time, String deadline, String task, String author, Priority priority)` служит для создания экзепляра записи, содержащей указанны в пенкте 1 поля.
3. Метод `int genId(int id)` служит для чтения значения поля "id задачи".
4. Метод `int getId()` служит для присвоения значения в поле "id задачи".
5. Метод `String getDate()` служит для чтения значения поля "дата постановки задачи".
6. Метод `void setDate(String dt)` служит для присвоения значения в поле "дата постановки задачи".
7. Метод `String getTime()` служит для чтения значения поля "время постановки задачи".
8. Метод `void setTime(String tm)` служит для присвоения значения в поле "время постановки задачи".
9. Метод `String getTask()` служит для чтения значения поля "содержание задачи".
10. Метод `void setTask(String newTask)` служит для присвоения значения в поле "содержание задачи".
11. Метод `String getDeadline()` служит для чтения значения поля "дедлайн".
12. Метод `void setDeadline(String dl)` служит для присвоения значения в поле "дедлайн".
13. Метод `String getAuthor()` служит для чтения значения поля "автор задачи".
14. Метод `void setAuthor(String author)` служит для присвоения значения в поле "автор задачи".
15. Метод `Priority getPriority()` служит для чтения значения приоритета задачи.
16. Метод `void setPriority(Priority prior)` служит для присвоения значения приоритета задачи.
17. Переопределены методы `int compareTo(Note o)` и `boolean equals(Object obj)`, входящие в состав интерфейса *Comparable<Note>* и описывающие механизм сравнения записей между собой.
18. Поле *Priority* содержит перечисление возможных значений, а также метод, который конвертирует строковые значения в тип данных *Priority*.

## Компонента INotebook.java (интерфейс) содержит в себе:
1. Сигнатура метода `void add(T note)` для добавления новой записи в текущее хранилище записей.
2. Сигнатура метода `T getTask(int index)` для получения значений записи по её id.
3. Сигнатура метода `void remove(int index)` для удаления записи из текущего хранилища по её id.
4. Сигнатура метода `boolean contains(int index)` для проверки есть ли уже такая запись в текущем хранилище.
5. Сигнатура метода `List<T> getNotes()` для получения всех записей из текущего хранилища.
6. Сигнатура метода `int count()` для получения количества всех записей в текущем хранилище.

## Компонента Notebook.java имлементирует интерфейс INotebook и содержит в себе:
1. Приватное поле *List<Note>* для хранения текущих данных о задачах (записей).
2. Конструктор `Notebook()` для создания экземпляра класса хранилища задач.
3. Переопределены методы `add(Note note)`, `getTask(int index)`, `remove(int index)`, `getNotes()`, `count()`, `contains(int index)`, описывающие процедуры добавления, чтения, удаления записей из текущего хранилища, получения размера хранилища (количества записей), а также проверки содежится ли запись с указанными параметрами в текущем хранилище.
4. Метод `void sort()` служит для инициализации процедуры сортировки записей по приоритету выполнения.

## Компонента PriorityComparator.java имлементирует интерфейс Comparator<Note> и содержит в себе:
1. Переопределен метод `compare(Note o1, Note o2)`, описывающие механизм сравнения двух записей по их приоритету. 
2. Метод `getAssignedValue(Note note)` для привязки значений приоритета записей к неким численным значениям для возможности сравнения значений приоритета записей.

## MVP (model-view-presenter) используется для структурирования кода и отвечает за логику работы с данными (Model), как эти данные будут отображаться их в интерфейсе пользователяе (View) и как будет осуществляться взаимодействие между модулями Model и View.
## Компонента Model.java имплементирует интерфейс Comparator<Note> и содержит в себе:
1. Приватные поля *currentBook*, *currentIndex*, *pathDB* для хранения текущего  состояния книги записей, индексе текущей записи в данной книге и пути к файлу, из которого загружаются и в который сохраняются данные о задачах (записи).
2. Конструктор `Model(String pathDB)` служит для создания экземпляра класса Модель, который в момент вызова создает пустую книгу записей и ассоциирует путь, где будет размещен файл для работы с данными.
3. Метод `currentNote()` получает из книги записей всю информацию о текущей записи по её индексу для дальнейшего отображения в интерфейсе пользователя.
4. Метод `load()` служит для загрузки данных из файла и добавления в книгу записей.
5. Метод `save()` служит для сохранения данных из книги записей в файл.
6. Метод `clear()` служит для очистки текущей книги записей.
7. Метод `getCurrBook()` служит для получения данных обо всех записях в текущей книге записей.
8. Метод `getCurrentIndex()` служит для получения информации о текущем индексе (позиции "курсора") в книге записей.
9. Метод `setCurrentIndex()` служит для установки текущего индекса (позиции "курсора") в определенное место в книге записей.

## Компонента Model.java имплементирует интерфейс Comparator<Note> и содержит в себе:
1. Приватные поля *model* и *view* для обеспечения взаимодествия с компонентами Model и View.
2. Конструкторы `Presenter(View view, String pathDb)` служит для создания экземпляра класса Презентер, который хранит в себе информацию о компонентах Model и Viewом.
3. Метод `loadFromFile()` описывает механизм загрузки данных из файла, добавления в книгу записей и её отображения в интерфейсе пользователя с использованием компоненты View.
4. Метод `add()` описывает механизм добавления новой записи (задачи) в книгу записей, а также как эта запись и текущая книга будут отображаться в интерфейсе пользователя.
5. Метод `remove()` описывает механизм удаления текущей записи (задачи) из книги записей, а также как книга записей будет отображаться в интерфейсе пользователя после выполнения процедуры удаления записи.
6. Метод `saveToFile()` инициализирует процедуру записи информации в файл.
7. Методы `next()` и `prev()` описывают механизм перемещения "курсора" при выборе пользователем определенной записи, а также как это действие будет отображаться в интерфейсе пользователя.
8. Метод `sortByPriority()` описывают механизм сортировки записей по приоритету их выполнения (по убыванию - сначала важные задачи, затем обычные, затем не важные), а также как это действие будет отображаться в интерфейсе пользователя.

## Компонента View.java (интерфейс) содержит в себе:
1. Сигнатура метода `void showMenu(int menu)` служит для отображения текущего меню в интерфейсе пользователя.
2. Сигнатура метода `void refresh()` служит для очистки экрана.
3. Сигнатура метода `void setCurrIndex(int value)` служит для установки "курсора" планнера на заданную запись.
4. Сигнатура метода `void print(Notebook currentBook)` служит для вывода в консоль информацию обо всех текущих записях в планнере.
5. Сигнатура метода `String inputText(String text)` служит для отображения приглашения пользователю ввести информацию и ввода информации.

## Что можно улучшить в коде:
1. Добавить сортировки по полям *deadline*, *author*, *date*, *id* - однако для этого нужно сделать несколько вложенных меню.
2. Добавить при загрузке возможность выбора файла, в котором хранятся данные, в том числе разных типов, а также возможность сохранения в разных типах. Опять же нужно сделать вложенное меню и продумать навигацию между уровнями меню.
3. В компоненте *Note.java* организовать хранение данных полей *data*, *time* и *deadline* не в String, а в LocalDate и LocalTime. Однако при вводе новой задачи необходимо предусмотреть проверку валидности данных и перезапрашивать пользователя в случае ошибки при вводе данных.
4. Если задач будет слишком много, понадобится внедрить механизм поиска записей.
5. Имеется ошибка некорректного отображения записей, сохраненных на русском языке.